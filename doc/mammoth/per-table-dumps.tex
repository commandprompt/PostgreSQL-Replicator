\documentclass{article}
\usepackage[utf8]{inputenc}

\author{Álvaro HERRERA Muñoz \\ with help from Alexey Klyukin}
\title{Mammoth Replicator: Per-table dumps}
\date{$Revision: 1649 $}

\newcommand{\catdump}{\emph{catalog dump}}
\newcommand{\Catdump}{\emph{Catalog Dump}}

\newcommand{\tabdump}{\emph{table dump}}
\newcommand{\Tabdump}{\emph{Table Dump}}

\newcommand{\tablist}{\emph{table list}}
\newcommand{\Tablist}{\emph{Table List}}

\begin{document}

\maketitle

\section{Goals}

\begin{enumerate}

\item Transmit the data from the master into the slaves

\item Avoid keeping excessively long transactions open on the master

\item Avoid unnecessary data transmission
when new tables are added or
existing, already-replicated tables are modified.

\end{enumerate}

\section{Definitions}

\begin{description}

\item[\Catdump] It's a full dump of the replication catalogs.
It is caused by a transaction
that adds or removes one or more tables
from the replication set.

\item[\Tabdump] It's a dump of a single user table's contents.
A \tabdump{} is consistent with regards to the data on the replication queue,
that is,
a transaction that was committed after the dump grabbed its snapshot
should place its DATA command after the \tabdump.
This causes a slave restoring the dump
and then the data following it
to have a consistent snapshot of the database
as seen on the master.

Also,
the DATA commands is independent of the DUMP,
that is, if a slave is following the DATA stream
and ignores a DUMP,
it continues to have a consistent view of the table.

\end{description}

\section{Random Notes}

\begin{enumerate}

\item A slave is said to be consistent
if and only if both these conditions hold:
\begin{itemize}
 \item The slave is in sync state
 \item There are no tables marked as \emph{waiting for dump}.
\end{itemize}

\item A transaction
that executes an operation that causes a \catdump{}
can not execute any other action which is replicated,
except other operations that cause \catdump.

\item There is no concept of partial \catdump,
and there are no incremental updates of the catalogs.
As soon as a catalog-updating command is executed,
the current transaction is marked as needing a \catdump.

\item It is not necessary to send a \catdump{} when 
a table is enabled for a slave
but has not yet been enabled centrally.

\item Marking a table as ``globally enabled'' for replication
is disallowed,
unless there is at least one slave
for which it is already enabled.

\end{enumerate}

\section{Implementation}

There are two types of dumps: full dumps and on-demand dumps.

A {\bf full dump} consists of a \catdump,
followed by a \tabdump{} for each replicated table.
A full dump is generated by the master
only when it connects to the MCP server
and noticed that it is out of sync,
or when the MCP server requests the full dump.

The MCP server should only request a full dump
if a slave signals that an error has occured and
it needs to reinitialize replication.

An {\bf on-demand dump} is a single table's \tabdump,
generated in response to a request from a slave.

A slave requests tables when it is in sync
and receives a \catdump{} which lists tables
for which it was not previously subscribed.
It then generates one requests for each such table.

The MCP server must have sufficient smarts
to avoid requesting the same table twice from the master,
if two or more slaves request the same table.

\subsection{\Catdump}

\paragraph{Generating a \catdump}
consists of a single transaction containing
a \tabdump{} of each of the replication catalogs.
Since this is a single transaction,
there is no need to have additional flags signalling
start or end of the dump.

\paragraph{Restoring a \catdump}
is like restoring plain table dumps,
with a couple of additional steps:

\begin{enumerate}
\item Immediately after the catalogs' contents have been restored,
the slave must send a table list to the MCP server,
which can use it to ``prune'' the replication queue
by skipping messages that the slave doesn't carry.

\item
The slave must be able to tell the set difference
between tables that are replicated after restoring the \catdump,
and tables that were previously replicated.
For those tables that are ``new'' in this dump,
the slave must generate a \tabdump{} request.
\end{enumerate}

Note that the MCP server must stop sending data from the queue
to the slave after every catalog dump,
until the slave has returned the table list.

\subsection{Full Dump}

\paragraph{Generating a full dump} looks like this:

\begin{enumerate}
\item Start a transaction
\item Put the DUMP~START message in the queue
\item Generate a \catdump
\item For each replicated table that has at least one subscribed slave,
\begin{enumerate}
 \item Commit the transaction
 \item Start a transaction
 \item grab the commit lock in exclusive mode
 \item take a transaction snapshot
 \item put the DUMP label in the queue
 \item release the commit lock
 \item generate the tuples to send
\end{enumerate}
\item Put the DUMP~END message in the queue
\item Commit the transaction
\end{enumerate}

The initial transaction start is needed to ensure that the \catdump{}
takes place in a transaction.

\paragraph{Restoring a Full Dump} is a bit more complicated.
The slave must first restore the catalog dump,
as described previously.
It needn't
take note of newly-added tables,
because the full dump is supposed to contain them all.
Each table in the new replication set
must be initially marked with a \emph{waiting for dump} flag.
This flag will be cleared as soon as the \tabdump{}
for that table has been restored.
Any DATA commands mentioning tables marked with the flag must be ignored.
When the DUMP~END message arrives,
if any tables still have the \emph{waiting for dump} flag,
the slave may send a table dump request for those tables,
and additionally log a WARNING message.

\subsection{Table Dumps}

\paragraph{Requesting a \tabdump} \label{sec:request} happens when a slave
notices that a \catdump{} mentions a table for which
it has no recent snapshot.

The slave must then send a TABLE~REQUEST message to the MCP server,
and it sets the \emph{waiting for dump} flag,
which will be cleared as soon as the \tabdump{} is received.
The TABLE~REQUEST message carries the table name.

For each table T,
the MCP server keeps track of
the recno of the latest \tabdump{} for that table,
which we call ``table dump recno for table T'' -- $ DumpRecno(T) $,
initially set to InvalidRecno.
Additionally, there's a boolean which indicates
whether this request has been filled by the master
-- $ ReqSatisfied(T) $,
initially true%
\footnote{This is slightly inconsistent,
because the initial state says that ``the request has been satisfied''
even though there hasn't been a request.
However,
we can distinguish this case by noting that
$DumpRecno(T)$ is InvalidRecno.}.

Upon receiving a table request from slave A,

\begin{enumerate}

\item If $ not\ ReqSatisfied(T) $,
disregard the request as a duplicate.
In this case,
the MCP server has requested the dump from the master,
but has not received the dump from the master yet.

\item Otherwise, if
$ DumpRecno(T)\textrm{ is not InvalidRecno and }DumpRecno(T) > \textrm{frecno}(\textrm{requesting slave}) $,
disregard the request as duplicate.
In this case, the MCP server already has the dump;
the slave will be up to date as soon as it catches up with the queue.

\item Otherwise,
the MCP server
forwards the request to the master
and sets $ ReqSatisfied(T) $ to false.

\end{enumerate}

Upon receiving a TABLE~REQUEST from the MCP server,
the master dumps the table to a new transaction,
with locking considerations equivalent to those explained
in full dump generation.

Upon receiving the table dump from the master, the MCP server
sets $ DumpReqno(T) $ to the dump's recno,
sets $ ReqSatisfied(T) $ to true,
and sends this dump only to the slaves
which have requested this table.
For any slaves that have this table on their table list
but did not send a request for the table,
the MCP server must skip sending the table dump
(this is just an optimization -- it is not needed for correctness.)

\paragraph{Restoring a \tabdump} is done by
truncating the table and
inserting the tuples that the \tabdump{} contains.
The \emph{waiting for dump} flag for that table 
can be cleared at this point.

\newpage
\subsection{Table List}

\paragraph{Table list data structure} on the MCP server consists of:

\begin{itemize}

\item {\bf char} $nspname$[NAMEDATALEN] - the name of the table namespace
\item {\bf char} $relname$[NAMEDATALEN] - the table's name
\item {\bf ullong} $DumpRecno$ - the record number of the last dump for this
table (see section \ref{sec:request})
\item {\bf bool} $ReqSatisfied$ the flag that helps  to determine if a dump 
for the table is already in queue (see section \ref{sec:request})
\item {\bf bool} $on\_master$ the flag telling whether the master is replicating
the table
\item {\bf bool} $on\_slave$[MAXSLAVES] same as above but for each slave
\item {\bf bool} $slave\_req$[MAXSLAVEs] flags to keep track of dump requests
for the table issued by each slave

\end{itemize}

Each slave stores its \tablist{} data in memory, 
saving it on disk after receiving \tablist{} updates 
or a signal from the peer. When receiving an update from 
the slave peer MCP would update the on-disk file using the
following algorithm:

\begin{enumerate}

\item Get the updated \tablist{} from the peer slave.
\item Acquire the \tablist{} lock in exclusive mode.
\item Read the \tablist{} file contents.
\item Update the \tablist{} in memory.
\item Store the \tablist{} to the temporary file.
\item Rename the temporary file into the result file.
\item Release the \tablist{} lock.
\item Send a signal to other  MCP processes.

\end{enumerate}

After receiving a signal from the peer MCP process would:

\begin{enumerate}

\item Acquire \tablist{} lock in a shared mode
\item Read the \tablist{} file contents
\item Release the \tablist{} lock

\end{enumerate}

\section{Queue pruning}

The MCP server must be able to prune its queue at some point,
to avoid running out of disk space.
The most important consideration to keep in mind is with regards
to a previous full dump: should the dump be kept?
Our answer seems to be that if the approximate total size of the queue
is larger than \verb|mcp_queue_max_size|,
then the dump must be removed from the queue.
If the queue is shorter than that,
then anything before the full dump can be removed.

Alexey notes that if the full dump's recno is less than
the minimum of frecno's for all active slaves,
and the approximate total size of the queue is bigger than
$ \max(\frac{mcp\_queue\_max\_size}{2}, mcp\_queue\_min\_size) $,
we can prune it too\footnote{He says ``connected'' slaves
rather than ``active'',
but I say we should try to keep the system working
even if a slave disconnects a falls behind for a bit.}.

If there isn't a full dump in the queue,
the data must be kept long enough to serve it to all active slaves.
If a slave falls behind,
we should attempt to keep the old data
until the slave catches up.
Otherwise,
we can prune when the queue is $ mcp\_queue\_min\_size $.

\end{document}
